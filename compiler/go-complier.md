## go-complier
[go-compiler](https://zhuanlan.zhihu.com/p/43845771)
### 1、解析

`cmd/compile/internal/syntax` （ 词法分析器(lexer)、 解析器(parser)、 语法树(syntax tree)）
在编译的第一阶段，源代码被标记化（词法分析）、解析（语法分析），并为每个源文件构造语法树（LCTT 译注：这里标记指 token，它是一组预定义的、能够识别的字符串，通常由名字和值构成，其中名字一般是词法的类别，如标识符、关键字、分隔符、操作符、文字和注释等；语法树，以及下文提到的 抽象语法树(Abstract Syntax Tree)（AST），是指用树来表达程序设计语言的语法结构，通常叶子节点是操作数，其它节点是操作码）。

每个语法树都是相应源文件的确切表示，其中节点对应于源文件的各种元素，例如表达式、声明和语句。语法树还包括位置信息，用于错误报告和创建调试信息。

### 2、类型检查和 AST 变换

`cmd/compile/internal/gc` （创建编译器 AST， 类型检查(type-checking)， AST 变换(AST transformation)）

gc 包中包含一个继承自（早期）C 语言实现的版本的 AST 定义。所有代码都是基于它编写的，所以 gc 包必须做的第一件事就是将 syntax 包（定义）的语法树转换为编译器的 AST 表示法。这个额外步骤可能会在将来重构。

然后对 AST 进行类型检查。第一步是名字解析和类型推断，它们确定哪个对象属于哪个标识符，以及每个表达式具有的类型。类型检查包括特定的额外检查，例如“声明但未使用”以及确定函数是否会终止。

特定变换也基于 AST 完成。一些节点被基于类型信息而细化，例如把字符串加法从算术加法的节点类型中拆分出来。其它一些例子是 死代码消除(dead code elimination)， 函数调用内联(function call inlining)和 逃逸分析(escape analysis)（LCTT 译注：逃逸分析是一种分析指针有效范围的方法）。